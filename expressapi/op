import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import replace from 'replace';
import fse from 'fs-extra';
import fsp from 'fs/promises';
import { generateApiKey } from 'generate-api-key';
import bcrypt from 'bcryptjs';
import path from 'path';
import { read } from 'read';

const { argv } = yargs(hideBin(process.argv))
.version()
.usage('Haszn√°lat: node op <command>  [name]')
.help()
.demandCommand(1, 'Not enough arguments!')
.command('make:model <name>',
  'Generates a new Sequelize model',
  (yargs) => {
    return yargs
      .positional('name', {
        type: 'string',
        description: 'Name of the model'
      })
  },
  async (argv) => {
    const { name } = argv;
    await copyModel(name);
  }
)
.command('make:controller <name>',
  'Generates a new controller',
  (yargs) => {
    return yargs
      .positional('name', {
        type: 'string',
        description: 'Name of the controller'
      })
  },
  async (argv) => {
    const { name } = argv;
    await copyController(name);
  }
)
.command('key:generate',
  'Generates a new API key',
  (yargs) => {
    return yargs
  },
  async (argv) => {
    startGenerateKey();
  }
)
.command('conf:generate',
  'Generates a new config file',
  (yargs) => {
    return yargs
  },
  async (argv) => {
    startGenerateConf();
  }
)
.command('admin:generate',
  'Generates a new admin user',
  (yargs) => {
    return yargs
  },
  async (argv) => {
    startGenerateAdmin();
  }
)
.command('db:import <model> <filePath> [sep]',
  `Import CSV or JSON file to database table

Examples:
node op db:import thing somethings.json
node op db:import thing somethings.csv
node op db:import thing somethings.csv ,
node op db:import thing somethings.csv :
node op db:import thing somethings.csv ";"

In CSV file the field names must match the model fields.
  `,
  (yargs) => {
    return yargs
      .positional('model', {
        type: 'string',
        description: 'Name of the model'
      })
      .positional('filePath', {
        type: 'string',
        description: 'Path to the file'
      })
      .positional('sep', {
        type: 'string',
        description: 'Separator for the CSV file'
      })
  },
  async (argv) => {
    const { model, filePath, sep } = argv;
    await runImportData(model, filePath, sep);
  }
)
.command('make:migration <name>',
  'Generates a new migration file',
  (yargs) => {
    return yargs
      .positional('name', {
        type: 'string',
        description: 'Name of the migration'
      })
  },
  async (argv) => {
    const { name } = argv;
    await createMigration(name);
  }
)
.command('migration:run [migrationName]',
  'Runs migrations',
  (yargs) => {
    return yargs
      .positional('migrationName', {
        type: 'string',
        description: 'Name of the migration'
      })
  },
  async (argv) => {
    const { migrationName } = argv;
    await startMigrations(migrationName);
  }
)
.command('migration:rollback',
  'Rolls back migrations',
  (yargs) => {
    return yargs
      .options({
        step: {
          type: 'number',
          description: 'Number of migrations to rollback',
          default: 1
        }
      })
  },
  async (argv) => {
    const { step } = argv;
    await rollbackMigrations(step);
  }
)
.command('migration:fresh',
  'Rolls back all migrations',
  (yargs) => {
    return yargs
  },
  async (argv) => {
    await freshMigrations();
  }
)
.command('migration:reset',
  'Rolls back all migrations',
  (yargs) => {
    return yargs
  },
  async (argv) => {
    await resetMigrations();
  }
)
.parse();

async function copyController(className) {
  const lowerName = className.toLowerCase()

  const src = 'templates/controllerTemplate.js'
  const dest = `app/controllers/${lowerName}Controller.js`

  if(await startCheckIfFileExists(dest)) {
    process.exit(1);
  }

  await fse.copy(src, dest)

  replace({
      regex: 'Thing',
      replacement: capitalizeFirstLetter(className),
      paths: [dest]
  })
  replace({
      regex: 'thing',
      replacement: className,
      paths: [dest]
  })
  replace({
    regex: 'things',
    replacement: className + 's',
    paths: [dest]
  })
}

async function copyModel(className) {
  const lowerName = className.toLowerCase()
  const src = 'templates/modelTemplate.js'
  const dest = `app/models/${lowerName}.js`

  if(await startCheckIfFileExists(dest)) {
    process.exit(1);
  }

  await fse.copy(src, dest)

  replace({
      regex: 'Thing',
      replacement: capitalizeFirstLetter(className),
      paths: [dest]
  })
  replace({
      regex: 'thing',
      replacement: className,
      paths: [dest]
  })
}

async function checkIfFileExists(filePath) {
  return await fsp.access(filePath)
      .then(() => true)
      .catch(() => false);
}

async function startCheckIfFileExists(filePath) {
  return await checkIfFileExists(filePath)
      .then(exists => {
          if (exists) {
              console.log(`The file ${filePath} exists!`);
              return true;
          } else {
              return false;
          }
      })
      .catch(error => console.log(error));
}

function capitalizeFirstLetter(word) {
  return word.charAt(0).toUpperCase() + word.slice(1);
}

function startGenerateKey() {
  console.log('Generate key...');
  const fileName = 'config/default.json'
  fsp.readFile(fileName)
      .then(body => JSON.parse(body))
      .then(json => {
          json.app.key = generateApiKey({method: 'bytes', length: 32})
          return json
      })
      .then(json => JSON.stringify(json, null, 4))
      .then(body => fse.writeFile(fileName, body, 'utf8'))
      .catch(error => console.log(error))
}

async function startGenerateConf() {
  console.log('Generate conf...');
  const sourceFileName = 'config/default.json.example';
  const destinationFileName = 'config/default.json';
  try {
    await fse.copyFile(sourceFileName, destinationFileName)
  } catch (error) {
    console.log(error)
  }
      
}

async function loadConfig() {
  try {
    const filePath = path.resolve('./config/default.json');
    const data = await fsp.readFile(filePath, 'utf8');
    const config = JSON.parse(data);
    return config;
  } catch (error) {
    console.error('Error loading config:', error);
    return null;
  }
}

async function inputPassword() {
  const password = await read({
    prompt: 'Password: ',
    silent: true,
    replace: '*'
  })
  return password
}

async function startGenerateAdmin() {
  console.log('Generate admin...')
  try {
    const config = await loadConfig();
    const isMemoryDb = config.db.path === ':memory:';
    if(isMemoryDb) {
      console.log('Admin cannot be created in memory db!')
    }else {
      const { default: User } = await import('./app/models/user.js')
      await User.sync()

      const isUserExist = await User.findOne({ where: { name: 'admin' } })
      if (isUserExist) {
        console.log('Admin already exists!')
        return;
      }
      const password = await inputPassword()
      const hashedPassword = await bcrypt.hash(password, 10);
      await User.create({
        name: 'admin',
        email: 'admin',
        password: hashedPassword
      })
      console.log('Admin created!')
    }
  } catch( err) {
    console.error('Error creating admin!')
    console.error(err)
  }
}

const importFromJson = async (model, filePath) => {
  try {
      const data = JSON.parse(await fsp.readFile(filePath, 'utf8'))
      await model.bulkCreate(data)
      console.log(`Data imported successfully! ${model.name}`)
  } catch (error) {
      console.error(error)
  }
}

const importFromCsv = async (model, filePath, sep) => {
  try {
      const data = await fsp.readFile(filePath, 'utf8')
      const clearData = data.replace(/"/g, '').trim()
      const rows = clearData.split('\n')
      const headerColumns = rows.shift().split(sep)
      
      const dataToInsert = rows.map(row => {
          const columns = row.split(sep).map(item => {
            const number = Number(item)
            return Number.isNaN(number) ? `${item}` : number
          })
          return headerColumns.reduce((obj, header, index) => {
              obj[header] = columns[index]
              return obj
          }, {})
      })

      await model.bulkCreate(dataToInsert)
      console.log(`Data imported successfully! ${model.name}`)
  } catch (error) {
      console.error(error)
  }
}

async function runImportData(model, filePath, sep=',') {
  
  if(!filePath || !model) {
      console.log('Usage: node db:import <modelName> <filePath> [sep]')
      process.exit(1)
  }
  
  try {
    await import(`./app/models/${model}.js`)
  } catch (error) {
    console.log(`The ${model} model file does not exist!`)
    process.exit(1)
  }

  try {
    await fsp.stat(filePath)
  } catch (error) {
    if (error.code === 'ENOENT') {
      console.log(`The file ${filePath} does not exist!`)
      process.exit(1)
    } else {
      console.error(error)
      process.exit(1)
    }
  }

  const modelInstance = await import(`./app/models/${model}.js`)
  const modelObject = modelInstance.default

  const ext = path.extname(filePath).toLowerCase()
  if(ext !== '.json' && ext !== '.csv') {
      console.log('The file must have .json or .csv extension!')
      process.exit(1)
  }
  const { default: sequelize } = await import('./app/database/database.js')
  try {
      await sequelize.sync({ force: true })
      await sequelize.authenticate()
      if(ext === '.csv') {
          await importFromCsv(modelObject, filePath, sep)
      }else {
          await importFromJson(modelObject, filePath)
      }        
  } catch (error) {
      console.error(error)
  }

}

async function createMigration(name) {
  console.log('Create a new migration...', name)

  const lowerName = name.toLowerCase()
  const date = new Date()
  const year = date.getFullYear()
  const month = String(date.getMonth() + 1).padStart(2, '0')
  const day = String(date.getDate()).padStart(2, '0')
  const hours = String(date.getHours()).padStart(2, '0')
  const minutes = String(date.getMinutes()).padStart(2, '0')
  const seconds = String(date.getSeconds()).padStart(2, '0')
  const timestamp = `${year}_${month}_${day}_${hours}${minutes}${seconds}`

  const migrationName = `${timestamp}_${lowerName}`

  const src = 'templates/migrationTemplate.js'
  const dest = `database/migrations/${migrationName}.js`

  if(await startCheckIfFileExists(dest)) {
    process.exit(1);
  }

  await fse.copy(src, dest)

  replace({
      regex: 'thing',
      replacement: name,
      paths: [dest]
  }) 

}

async function getUmzug() {
  const { default: sequelize } = await import('./app/database/database.js')
  const { Umzug, SequelizeStorage } = await import('umzug')

  const umzug = new Umzug({
    migrations: { glob: './database/migrations/*.js' },
    context: sequelize.getQueryInterface(),
    storage: new SequelizeStorage({ sequelize }),
    logger: console
  })

  return umzug
}

async function startMigrations(name) {
  if(name) {
    await runOneMigration(name)
  } else {
    await runMigrations()
  }
}

async function runOneMigration(name) {
  console.log('Run one migration...', name)

  if(!name.endsWith('.js')) {
    name += '.js'
  }

  const migrationPath = `database/migrations/${name}`
  if(!await startCheckIfFileExists(migrationPath)) {
    console.log(`The migration file ${migrationPath} not already exists.`)
    process.exit(1)
  }

  const umzug = await getUmzug()
  await umzug.up()
}

async function runMigrations() {
  console.log('Run migrations...')
  const umzug = await getUmzug()
  await umzug.up()
}

async function resetMigrations() {
  console.log('Reset migrations...')
  const umzug = await getUmzug()
  await umzug.down({ to: 0 })
}

async function freshMigrations() {
  console.log('Fresh migrations...')
  await resetMigrations()
  await runMigrations()
}

async function rollbackMigrations(step = 1) {
  console.log('Rollback migrations...')
  const umzug = await getUmzug()
  await umzug.down({ step: step })
}
